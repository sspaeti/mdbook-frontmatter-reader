use mdbook::book::{Book, BookItem};
use mdbook::errors::Error;
use mdbook::preprocess::{CmdPreprocessor, Preprocessor, PreprocessorContext};
use clap::Command;
use gray_matter::Matter;
use serde::{Deserialize, Serialize};
use std::process;

pub struct FrontMatterPreprocessor;

impl Preprocessor for FrontMatterPreprocessor {
    fn name(&self) -> &str {
        "frontmatter"
    }

    fn run(&self, ctx: &PreprocessorContext, mut book: Book) -> Result<Book, Error> {
        let matter = Matter::new();
        let mut has_frontmatter = false;

        book.for_each_mut(|section| {
            if let BookItem::Chapter(chapter) = section {
                if chapter.path.is_some() {
                    let parsed = matter.parse(&chapter.content);
                    if !parsed.data.is_empty() {
                        has_frontmatter = true;
                        chapter.content = parsed.content;
                        // Here, you might want to do something with the parsed front matter,
                        // like storing it in a custom field or processing it further.
                        // This example simply detects front matter presence.
                    }
                }
            }
        });

        if has_frontmatter {
            // Optionally log or handle chapters with front matter
        }

        Ok(book)
    }

    fn supports_renderer(&self, renderer: &str) -> bool {
        // Adjust according to which renderer(s) you want to support
        renderer != "not-supported"
    }
}

// The following main function and associated command-line parsing
// allow this preprocessor to be invoked by mdBook.
fn main() {
    let matches = Command::new("mdbook-frontmatter")
        .subcommand_required(true)
        .subcommand(
            Command::new("supports")
                .arg(clap::arg!(<RENDERER> "The renderer to check support for"))
        )
        .get_matches();

    let preprocessor = FrontMatterPreprocessor;

    if let Some(sub_args) = matches.subcommand_matches("supports") {
        let renderer = sub_args.get_one::<String>("RENDERER").expect("Required argument");
        let supported = preprocessor.supports_renderer(renderer);
        process::exit(if supported { 0 } else { 1 });
    } else {
        if let Err(e) = CmdPreprocessor::handle_preprocessing(&preprocessor) {
            eprintln!("{}", e);
            process::exit(1);
        }
    }
}
